
### 介绍
正则表达式就是记录文本规则的代码。

在编写处理字符串的程序或网页时，经常会有查找符合某些复杂规则的字符串的需要。比如找出一段文本中所有的数字。

如果你想查找某个目录下的所有的Word文档的话，你会搜索*.ppt。在这里，*会被解释成任意的字符串。




和通配符类似，正则表达式也是用来进行文本匹配的工具，只不过比起通配符，它能更精确地描述你的需求——当然，代价就是更复杂。

### 元字符


> hi

匹配含有hi的字符串，包括him，her，history。



> \bhi\b

精确查找，只匹配hi。

\b是一个元字符，代表单词的开始和结束，它匹配一个位置。


> 0\d\d-\d\d\d\d\d\d\d\d

\d匹配数字。



这个式子可以化简为



> 0\d{2}-\d{8}

第一个表示数字重复两次，第二个表示重复八次。

\D [^\d]匹配非数字字符。

.匹配任意字符

\w匹配字母数字下划线

> \ba\w*\b

首先匹配a开头，\w匹配字母数字下划线或汉字，*表示 *之前的可以任意使用任意次（**可以是0次**）。



> \d+

匹配任意个数字 +表示匹配1次或任意次，注意至少要1次。



> \b\w{6}\b   

匹配6个字符的字符串。

> \d{4,10}

匹配4到10个字符串，包括4和10。

### 字符转义
如果你想查找元字符本身，比如*，-，那么你可以用一个 
反斜杠+查找的元字符，如果想查找\,那么就是\\\。

### 重复


### 字符类

如果想要匹配没有预定义元字符的字符集合，比如1 3 5，或者aeiou，那么应该怎么办呢？

> [aeiou] [135]

试一下更复杂的表达式

> \\(?0\d{2}[) -]?\d{8}

拆除一部分一部分分析。
> \\(?0\d{2}

表示 **(** 出现1次或0次，然后是一个0，再加2个数字，

> [) -]?

再加上右括号 空格 减号中的1个，这个出现的次数是1次或0次，

> \\d{8}

最后再加上8个数字。
可以匹配

```
(012)12345678
012)12345678
(012 12345678
(012-12345678
01212345678
```

### 分枝条件

有时候我们需要多种条件，比如有三位区号，但是我也要四位区号。类似if ，else if。

分支条件指的是有几种规则，只要满足任意一个规则，那么就可以匹配。

> \\(0\d{3}\\)[- ]?\d{8}|0\d{3}[- ]?\d{8}

| 将两个表达式隔开，一个一个分析。

有括号的以0开头四位区号，第二个没括号。

匹配分支时，从左到右，左边满足就不会管右边。

### 分组

我们已经学过数字和字符的重复，比如\d{3},3个数字，那么我们也可以对表达式进行重复。

通过小括号来指定子表达式，然后可以指定子表达式的重复次数。

> (\d{1,3}\\.){3}\d{1,3}

简单ip地址匹配表达式，\d{1,3}匹配1到3位数字，\\.匹配符号 . ,被小括号包括，说明是个分组，后面的{3}表示分组重复的次数。

不过这个表达式不够严谨，会匹配到不存在的ip地址。
比如666.666.666.666。

正确的匹配ip表达式
> ((2[0-4]\d|25[1-5]|[01]?\d\d?)\\.){3}(2[0-4]\d|25[1-5]|[01]?\d\d?)

依然一个一个看，ip地址的数字范围是[0,255]。
可划分为:
- [0,9]
- [10,99]
- [100,199]
- [200,249]
- [250,255]

> [01]?\d\d?

匹配[0,199]

> 2[0-4]\d

匹配[200,249]

> 25[1-5]

匹配[250,255]

### 反义



### 后向引用

后向引用用于重复搜索

> (\d)\d\1

第一个\d是一个匹配数字捕获分组，第二个普通的匹配数字
，\1是匹配捕获分组中的字符。

结果就是匹配类似 303 575这种字符串。

> \b(\w+)\b\s+\1\b

(\w+)是一个分组，匹配一个单词，\1表示的前面出现过的分组1的内容。\s+匹配一个或多个空格。

也可以自己给分组起个名称。

> (?<first>\w+)

那么first就是分组的名称了，反向引用就是

> \k<first>

### 零宽断言

零宽断言用于指定一个位置, 用于查找在某些内容(但并不包括这些内容)之前或之后的东西.

> \w+(?=ing)

匹配以ing结尾的前面部分（不包括ing）。

> (?<=sin)\w+

匹配sin开头的单词的后半部分，不包括sin。


